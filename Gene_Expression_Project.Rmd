---
title: "Gene Expression Project"
author: "Fenny and Daniëlle"
date: '2023-04-26'
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
```

# Hippocampal subfield transcriptome analysis in schizophrenia psychosis
```{r}
library(tidyr)
library(dplyr)
library(affy)
library(scales)
library(ggplot2)
library('DESeq2')
library('PoiClaClu')
```

The count data is loaded into R.

Table 1: Raw counts data
```{r}
count_data <- "Sample_Subfields_Counts.txt"
counts <- read.table(file = count_data, header = TRUE)
head(counts)



dim(counts)
#str(counts)

control_CA1 <- c(1:13)
case_CA1 <- c(14:26)
control_CA3 <- c(27:39)
case_CA3 <- c(40:52)
control_DG <- c(53:65)
case_DG <- c(66:78)


counts_CA1 <- counts[, 1:26]
#counts_CA1
counts_CA3 <- counts[, 27:52]
#counts_CA3
counts_DG <- counts[, 53:78]
#counts_DG
```

The data of the counts was split based on the hippocampal subfield and tidied using tidyr (table 2-4).

Table 2: Tidy CA1 data
```{r}
counts_CA1_tidy <- pivot_longer(data = counts_CA1,
             cols=1:26,
             #names_pattern="(CA1_CTL|CA1_SZ).",
             names_to ="sample",
             values_to = "value")
head(counts_CA1_tidy)
```

Table 3: Tidy CA3 data
```{r}
counts_CA3_tidy <- pivot_longer(data = counts_CA3,
             cols=1:26,
             #names_pattern="(CA1_CTL|CA1_SZ).",
             names_to ="sample",
             values_to = "value")
head(counts_CA3_tidy)
```

Table 4: Tidy DG data
```{r}
counts_DG_tidy <- pivot_longer(data = counts_DG,
             cols=1:26,
             #names_pattern="(CA1_CTL|CA1_SZ).",
             names_to ="sample",
             values_to = "value")
head(counts_DG_tidy)
```


```{r}
counts_CA1_tidy$log2 <- log2(counts_CA1_tidy$value + 1)
counts_CA3_tidy$log2 <- log2(counts_CA3_tidy$value + 1)
counts_DG_tidy$log2 <- log2(counts_DG_tidy$value + 1)

ggplot(data = counts_CA1_tidy, mapping = aes(x = sample, y = log2))+
geom_boxplot()+
  scale_x_discrete(guide = guide_axis(angle = 90))

sums <- colSums(counts_CA1)/1e6
CA1_sequence_depth = data.frame(sample=names(sums), depth=sums)
CA1_sequence_depth %>% ggplot(mapping = aes(x = sample, y=sums)) + geom_col() +
   scale_x_discrete(guide = guide_axis(angle = 90))

ggplot(data = counts_CA3_tidy, mapping = aes(x = sample, y = log2))+
geom_boxplot()+
  scale_x_discrete(guide = guide_axis(angle = 90))



ggplot(data = counts_DG_tidy, mapping = aes(x = sample, y = log2))+
geom_boxplot()+
scale_x_discrete(guide = guide_axis(angle = 90))
```

The data is separated in control and case groups for each subfield and visualized by creating a boxplot for each group (figure 1-6).

```{r}
control_ca1 <- c(1:13)
case_ca1 <- c(14:26)
control_ca3 <- c(27:39)
case_ca3 <- c(40:52)
control_dg <- c(53:65)
case_dg <- c(66:78)

par(cex = 0.8)
boxplot(log2(counts[control_ca1] + 1), outline = T, cex.names = 0.2, col = "green", las = 2)
```
Figure 1: Raw counts boxplot control group CA1

```{r}
par(cex = 0.8)
boxplot(log2(counts[case_ca1] + 1), outline = T, cex.names = 0.2, col = "blue", las = 2)
```
Figure 2: Raw counts boxplot case group CA1

```{r}
par(cex = 0.8)
boxplot(log2(counts[control_ca3] + 1), outline = T, cex.names = 0.2, col = "grey", las = 2)
```
Figure 3: Raw counts boxplot control group CA3

```{r}
par(cex = 0.8)
boxplot(log2(counts[case_ca3] + 1), outline = T, cex.names = 0.2, col = "cyan", las = 2)
```
Figure 4: Raw counts boxplot case group CA3

```{r}
par(cex = 0.8)
boxplot(log2(counts[control_dg] + 1), outline = T, cex.names = 0.2, col = "red", las = 2)
```
Figure 5: Raw counts boxplot control group DG

```{r}
par(cex = 0.8)
boxplot(log2(counts[case_dg] + 1), outline = T, col = "yellow", las = 2)
```
Figure 6: Raw counts boxplot case group DG

A density plot is made for all the samples to visualize the distribution of the log2 of the count data.
```{r}
myColors <- hue_pal()(4)

plotDensity(log2(counts + 0.1), col=rep(myColors, each=3),
            lty=c(1:ncol(counts)), xlab='Log2(count)',
            main='Expression Distribution')

legend('topright', names(counts), lty=c(1:ncol(counts)),
       col=rep(myColors, each=3))
abline(v=-1.5, lwd=1, col='red', lty=2)
```
Figure 7: Density plot of count distribution for all samples 

Barplots are created for each control and case group in which the total raw count is shown of each sample.
```{r}
barplot(colSums(counts[control_ca1]) / 1e6, col = "#D6F6DD", las = 2, cex.names = 0.8)
```
Figure 8: Barplot showing the total reads per million for each subject in the control group for subfield CA1

```{r}
barplot(colSums(counts[case_ca1]) / 1e6, col = "#DAC4F7", las = 2, cex.names = 0.8)
```
Figure 9: Barplot showing the total reads per million for each subject in the case group for subfield CA1

```{r}
barplot(colSums(counts[control_ca3]) / 1e6, col = "#CCCCCC", las = 2, cex.names = 0.8)
```
Figure 10: Barplot showing the total reads per million for each subject in the control group for subfield CA3

```{r}
barplot(colSums(counts[case_ca3]) / 1e6, col = "#ACECF7", las = 2, cex.names = 0.8)
```
Figure 11: Barplot showing the total reads per million for each subject in the case group for subfield CA3

```{r}
barplot(colSums(counts[control_dg]) / 1e6, col = "#F4989C", las = 2, cex.names = 0.8)
```
Figure 12: Barplot showing the total reads per million for each subject in the control group for subfield DG

```{r}
barplot(colSums(counts[case_dg]) / 1e6, col = "#EBD2B4", las = 2, cex.names = 0.8)
```
Figure 13: Barplot showing the total reads per million for each subject in the case group for subfield DG

Several DESeq2 functions are utilized to transform the raw read count data and calculating sample distances. A DESeqDataSet is made using the count data and an annotation which consists of the sample names. The dataset is used to transform the data into normalized data.
```{r}
(ddsMat <- DESeqDataSetFromMatrix(countData = counts,
                                  colData = data.frame(samples = names(counts)),
                                  design = ~ 1))

# Perform normalization
rld.dds <- vst(ddsMat)
# 'Extract' normalized values
rld <- assay(rld.dds)
sampledists <- dist( t( rld ))
```

```{r}
#annotation <- data.frame(subfield = factor(rep(1:3, each = 26), 
 #                                         labels = c("CA1", "CA3", "DG")),
  #                       type = factor(rep(rep(1:2, each = 13), 3),
   #                                      labels = c("control", "schizophrenia")))
                         
# Set the rownames of the annotation dataframe to the sample names (required)
#rownames(annotation) <- names(counts)
```

```{r}
load("~/Documents/Capstone project/project/annotation.RData")
```


```{r}

# Note: uses the raw-count data, PoissonDistance performs normalization
# set by the 'type' parameter (uses DESeq)
dds <- assay(ddsMat)
poisd <- PoissonDistance( t(dds), type = "deseq")
# Extract the matrix with distances
samplePoisDistMatrix <- as.matrix(poisd$dd)
# Calculate the MDS and get the X- and Y-coordinates
mdsPoisData <- data.frame( cmdscale(samplePoisDistMatrix) )

# And set some better readable names for the columns
names(mdsPoisData) <- c('x_coord', 'y_coord')
```



```{r}
groups <- factor(rep(1:6, each=13), 
                 labels = c("CA1_CTL", "CA1_SZ", "CA3_CTL", "CA3_SZ", "DG_CTL", "DG_SZ"))
coldata <- names(counts)

color_palette <- c("#D6F6DD", "#DAC4F7", "#CCCCCC", "#ACECF7", "#F4989C", "#EBD2B4")

# Create the plot using ggplot

ggplot(mdsPoisData, aes(x_coord, y_coord, color = groups, label = coldata)) + 
  geom_text(size = 3) +
  scale_colour_manual(values=c("green", "blue", "grey", "cyan", "red", "yellow"))+
  ggtitle('Multi Dimensional Scaling') +
  labs(x = "Poisson Distance", y = "Poisson Distance") +
  theme_bw()+
  labs(caption = "Figure: MDS plot")
```

```{r}
count_nooutlier <- counts[ ,-38]
col1 <-rep(c("CA1", "CA3", "DG"), times = c(26, 25, 26))
col2 <-rep(c("control", "sz", "control", "sz", "control", "sz"), times = c(13, 13, 12, 13, 13, 13))
 
annotation_rm_ctl12 <- data.frame(col1, col2)
                        
rownames(annotation_rm_ctl12) <- names(count_nooutlier)
```

```{r}
(ddsMat_rm_CA3_CTL_12 <- DESeqDataSetFromMatrix(countData = count_nooutlier,
                                  colData = data.frame(samples = names(count_nooutlier)),
                                  design = ~ 1))

# Perform normalization
rld.dds <- vst(ddsMat)
# 'Extract' normalized values
rld <- assay(rld.dds)
sampledists <- dist( t( rld ))
```



```{r}
annotation_rm_CA3
```


```{r}

# Note: uses the raw-count data, PoissonDistance performs normalization
# set by the 'type' parameter (uses DESeq)
dds <- assay(ddsMat_rm_CA3_CTL_12)
poisd <- PoissonDistance( t(dds), type = "deseq")
# Extract the matrix with distances
samplePoisDistMatrix <- as.matrix(poisd$dd)
# Calculate the MDS and get the X- and Y-coordinates
mdsPoisData_rm_CA3_CTL_12 <- data.frame( cmdscale(samplePoisDistMatrix) )

# And set some better readable names for the columns
names(mdsPoisData_rm_CA3_CTL_12 ) <- c('x_coord', 'y_coord')
```

```{r}
groups <- factor(rep(c("CA1_CTL", "CA1_SZ", "CA3_CTL", "CA3_SZ", "DG_CTL", "DG_SZ"), times = c(13, 13, 12, 13, 13, 13)))
coldata <- names(count_nooutlier)


# Create the plot using ggplot
ggplot(mdsPoisData_rm_CA3_CTL_12, aes(x_coord, y_coord, color = groups, label = ".")) + 
  geom_text(size = 20) +
  scale_colour_manual(values=c("green", "blue", "grey", "cyan", "red", "yellow"))+
  ggtitle('Multi Dimensional Scaling') +
  labs(x = "Poisson Distance", y = "Poisson Distance") +
  theme_bw()+
  labs(caption = "Figure: MDS plot with outlier removed")
```

TODOs voor kwaliteitscontrole:
- normaliseren met DESeq2 vst()
- annotation dataframe maken (zie 3.4.3)
- MDS (eerst in 1 plot)

The raw counts data was normalized again by calculating the fragments per million mapped fragments (FPM), this is equal to CPM (counts per million). The log2 was calculated of these given values. 

```{r}
counts.fpm <- log2( (counts / (colSums(counts) / 1e6)) + 1 )
```

```{r}
annotation$Group <- paste(annotation$Condition, annotation$Region, annotation$Drug, sep="_")
dds <- DESeqDataSetFromMatrix(countData = counts,
                              colData = annotation,
                              design = ~ 0 + Group)
dds <- DESeq(dds)
resultsNames(dds)
res_CA1 <- results(dds, contrast = c("Group", "schizophrenia_CA1_ON", "schizophrenia_CA1_OFF"), alpha = 0.05)
summary(res_CA1)

res_CA3 <- results(dds, contrast = c("Group", "schizophrenia_CA3_ON", "schizophrenia_CA3_OFF"), alpha = 0.05)
summary(res_CA3)

res_DG <- results(dds, contrast = c("Group", "schizophrenia_DG_ON", "schizophrenia_DG_OFF"), alpha = 0.05)
summary(res_DG)
```


volcano plot maken

A volcano plot was made using the results from deseq

```{r}
library(EnhancedVolcano)
library(ggrepel)

## Simple function for plotting a Volcano plot, returns a ggplot object
deseq.volcano <- function(res, datasetName) {
  return(EnhancedVolcano(res, x = 'log2FoldChange', y = 'padj',
                         lab=rownames(res),
                         title = paste(datasetName, ""),
                         subtitle = bquote(italic('FDR <= 0.05 and absolute FC >= 2')),
                         # Change text and icon sizes
                         labSize = 3, pointSize = 1.5, axisLabSize=10, titleLabSize=12,
                         subtitleLabSize=8, captionLabSize=10,
                         # Disable legend
                         legendPosition = "none",
                         # Set cutoffs
                         pCutoff = 0.05, FCcutoff = 2))
}

deseq.volcano(res = res_CA1, datasetName = "CA1")
deseq.volcano(res = res_CA3, datasetName = "CA3")
deseq.volcano(res = res_DG, datasetName = "DG")
```


```{r}
pval_threshold <- 0.05
CA1.degs <- row.names(res_CA1[which(res_CA1$padj <= pval_threshold), ])
CA3.degs <- row.names(res_CA3[which(res_CA3$padj <= pval_threshold), ])
DG.degs <- row.names(res_DG[which(res_DG$padj <= pval_threshold), ])



```


```{r}
library(gplots)
# Create a Venn-diagram given just the list of gene-names for both sets



venn( list(CA1=CA1.degs,CA3=CA3.degs,DG=DG.degs ) )
  
```
Figure: Venn diagram showing the overlap of differently regulated genes between schizophrenia patients ON and OFF medication in the three hippocampal subfields: CA1, CA3 and DG


sz_CA1_off - ctl_CA1: 57, 2

sz_CA1_on - sz_CA1_off: 1, 48

sz_CA1_on - ctl_CA1: 0, 1


sz_ca3_off - ctl_ca3: 26, 2

sz_ca3_on - sz_ca3_off: 171, 190

sz_ca3_on - ctl_ca3: 31, 358


sz_dg_off - ctl_dg: 11, 3

sz_dg_on - sz_dg_off: 86, 14

sz_dg_on - ctl_dg: 144, 12



MTRNR2 gene stands out in the volcano plot of each comparison. This is a neuroprotective gene that protects against neuronal death induced by alzheimer. Often shows higher expression in Schizophrenia cases than in control subjects. Was not mentioned in the article.


references

Ivanova, E. M., Kandilarova, S. M., Lukanov, T. I., Naumova, E. J., Akabalieva, K. V., & Milanova, V. K. (2021). NGS-based mtDNA Profiling Could Reveal Genetic Alterations in Schizophrenia. Current topics in medicinal chemistry, 21(11), 938–948. https://doi.org/10.2174/1568026621666210521155500
