---
title: "Gene Expression Project"
author: "Fenny and DaniÃ«lle"
date: '2023-04-26'
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Hippocampal subfield transcriptome analysis in schizophrenia psychosis
```{r}
library(tidyr)
library(dplyr)
library(affy)
library(scales)
library(ggplot2)
library('DESeq2')
library('PoiClaClu')
```

The count data is loaded into R.

Table 1: Raw counts data
```{r}
count_data <- "Sample_Subfields_Counts.txt"
counts <- read.table(file = count_data, header = TRUE)
head(counts)



dim(counts)
#str(counts)

control_CA1 <- c(1:13)
case_CA1 <- c(14:26)
control_CA3 <- c(27:39)
case_CA3 <- c(40:52)
control_DG <- c(53:65)
case_DG <- c(66:78)


counts_CA1 <- counts[, 1:26]
#counts_CA1
counts_CA3 <- counts[, 27:52]
#counts_CA3
counts_DG <- counts[, 53:78]
#counts_DG
```

The data of the counts was split based on the hippocampal subfield and tidied using tidyr (table 2-4).

Table 2: Tidy CA1 data
```{r}
counts_CA1_tidy <- pivot_longer(data = counts_CA1,
             cols=1:26,
             #names_pattern="(CA1_CTL|CA1_SZ).",
             names_to ="sample",
             values_to = "value")
head(counts_CA1_tidy)
```

Table 3: Tidy CA3 data
```{r}
counts_CA3_tidy <- pivot_longer(data = counts_CA3,
             cols=1:26,
             #names_pattern="(CA1_CTL|CA1_SZ).",
             names_to ="sample",
             values_to = "value")
head(counts_CA3_tidy)
```

Table 4: Tidy DG data
```{r}
counts_DG_tidy <- pivot_longer(data = counts_DG,
             cols=1:26,
             #names_pattern="(CA1_CTL|CA1_SZ).",
             names_to ="sample",
             values_to = "value")
head(counts_DG_tidy)
```


```{r}
counts_CA1_tidy$log2 <- log2(counts_CA1_tidy$value + 1)
counts_CA3_tidy$log2 <- log2(counts_CA3_tidy$value + 1)
counts_DG_tidy$log2 <- log2(counts_DG_tidy$value + 1)

ggplot(data = counts_CA1_tidy, mapping = aes(x = sample, y = log2))+
geom_boxplot()+
  scale_x_discrete(guide = guide_axis(angle = 90))

sums <- colSums(counts_CA1)/1e6
CA1_sequence_depth = data.frame(sample=names(sums), depth=sums)
CA1_sequence_depth %>% ggplot(mapping = aes(x = sample, y=sums)) + geom_col() +
   scale_x_discrete(guide = guide_axis(angle = 90))

ggplot(data = counts_CA3_tidy, mapping = aes(x = sample, y = log2))+
geom_boxplot()+
  scale_x_discrete(guide = guide_axis(angle = 90))



ggplot(data = counts_DG_tidy, mapping = aes(x = sample, y = log2))+
geom_boxplot()+
scale_x_discrete(guide = guide_axis(angle = 90))
```



```{r}
control_ca1 <- c(1:13)
case_ca1 <- c(14:26)
control_ca3 <- c(27:39)
case_ca3 <- c(40:52)
control_dg <- c(53:65)
case_dg <- c(66:78)

boxplot(log2(counts[control_ca1] + 1), outline = T, cex.names = 0.2, col = "green", las = 2)
boxplot(log2(counts[case_ca1] + 1), outline = T, cex.names = 0.2, col = "blue", las = 2)
boxplot(log2(counts[control_ca3] + 1), outline = T, cex.names = 0.2, col = "grey", las = 2)
boxplot(log2(counts[case_ca3] + 1), outline = T, cex.names = 0.2, col = "cyan", las = 2)
boxplot(log2(counts[control_dg] + 1), outline = T, cex.names = 0.2, col = "red", las = 2)
boxplot(log2(counts[case_dg] + 1), outline = T, cex.lab = 0.2, col = "yellow", las = 2)

```
```{r}
myColors <- hue_pal()(4)

plotDensity(log2(counts + 0.1), col=rep(myColors, each=3),
            lty=c(1:ncol(counts)), xlab='Log2(count)',
            main='Expression Distribution')

legend('topright', names(counts), lty=c(1:ncol(counts)),
       col=rep(myColors, each=3))
abline(v=-1.5, lwd=1, col='red', lty=2)
```

```{r}
barplot(colSums(counts[control_ca1]) / 1e6, col = "#D6F6DD")
barplot(colSums(counts[case_ca1]) / 1e6, col = "#DAC4F7")
barplot(colSums(counts[control_ca3]) / 1e6, col = "#CCCCCC", las =2)
barplot(colSums(counts[case_ca3]) / 1e6, col = "#ACECF7")
barplot(colSums(counts[control_dg]) / 1e6, col = "#F4989C")
barplot(colSums(counts[case_dg]) / 1e6, col = "#EBD2B4", las = 2)
```


```{r}
(ddsMat <- DESeqDataSetFromMatrix(countData = counts,
                                  colData = data.frame(samples = names(counts)),
                                  design = ~ 1))

# Perform normalization
rld.dds <- vst(ddsMat)
# 'Extract' normalized values
rld <- assay(rld.dds)
sampledists <- dist( t( rld ))
```

```{r}
#annotation <- data.frame(subfield = factor(rep(1:3, each = 26), 
 #                                         labels = c("CA1", "CA3", "DG")),
  #                       type = factor(rep(rep(1:2, each = 13), 3),
   #                                      labels = c("control", "schizophrenia")))
                         
# Set the rownames of the annotation dataframe to the sample names (required)
#rownames(annotation) <- names(counts)
```

```{r}
load("~/Documents/Capstone project/project/annotation.RData")
```


```{r}

# Note: uses the raw-count data, PoissonDistance performs normalization
# set by the 'type' parameter (uses DESeq)
dds <- assay(ddsMat)
poisd <- PoissonDistance( t(dds), type = "deseq")
# Extract the matrix with distances
samplePoisDistMatrix <- as.matrix(poisd$dd)
# Calculate the MDS and get the X- and Y-coordinates
mdsPoisData <- data.frame( cmdscale(samplePoisDistMatrix) )

# And set some better readable names for the columns
names(mdsPoisData) <- c('x_coord', 'y_coord')
```


```{r}
groups <- factor(rep(1:6, each=13), 
                 labels = c("CA1_CTL", "CA1_SZ", "CA3_CTL", "CA3_SZ", "DG_CTL", "DG_SZ"))
coldata <- names(counts)

color_palette <- c("#D6F6DD", "#DAC4F7", "#CCCCCC", "#ACECF7", "#F4989C", "#EBD2B4")

# Create the plot using ggplot
ggplot(mdsPoisData, aes(x_coord, y_coord, color = groups, label = coldata)) + 
  geom_text(size = 3) +
  scale_colour_manual(values=c("green", "blue", "grey", "cyan", "red", "yellow"))+
  ggtitle('Multi Dimensional Scaling') +
  labs(x = "Poisson Distance", y = "Poisson Distance") +
  theme_bw()+
  labs(caption = "Figure: MDS plot")
```
```{r}
groups <- factor(rep(1:6, each=13), 
                 labels = c("CA1_CTL", "CA1_SZ", "CA3_CTL", "CA3_SZ", "DG_CTL", "DG_SZ"))
coldata <- names(counts)

mds_removed_CTL_12 <- mdsPoisData %>%
filter(x_coord > -20000) %>%
ggplot(aes(x_coord, y_coord, color = groups, label = coldata)) + 
  geom_text(size = 3) +
  scale_colour_manual(values=c("green", "blue", "grey", "cyan", "red", "yellow"))+
  ggtitle('Multi Dimensional Scaling') +
  labs(x = "Poisson Distance", y = "Poisson Distance") +
  theme_bw()
```



```{r}
(ddsMat_rm_CA3_CTL_12 <- DESeqDataSetFromMatrix(countData = count_nooutlier,
                                  colData = data.frame(samples = names(count_nooutlier)),
                                  design = ~ 1))

# Perform normalization
rld.dds <- vst(ddsMat)
# 'Extract' normalized values
rld <- assay(rld.dds)
sampledists <- dist( t( rld ))
```

```{r}
count_nooutlier <- counts[ ,-38]



col1 <-rep(c("CA1", "CA3", "DG"), times = c(26, 25, 26))
col2 <-rep(c("control", "sz", "control", "sz", "control", "sz"), times = c(13, 13, 12, 13, 13, 13))
 
annotation_rm_ctl12 <- data.frame(col1, col2)
                        
rownames(annotation_rm_ctl12) <- names(count_nooutlier)
```

```{r}

# Note: uses the raw-count data, PoissonDistance performs normalization
# set by the 'type' parameter (uses DESeq)
dds <- assay(ddsMat_rm_CA3_CTL_12)
poisd <- PoissonDistance( t(dds), type = "deseq")
# Extract the matrix with distances
samplePoisDistMatrix <- as.matrix(poisd$dd)
# Calculate the MDS and get the X- and Y-coordinates
mdsPoisData_rm_CA3_CTL_12 <- data.frame( cmdscale(samplePoisDistMatrix) )

# And set some better readable names for the columns
names(mdsPoisData_rm_CA3_CTL_12 ) <- c('x_coord', 'y_coord')
```

```{r}
groups <- factor(rep(c("CA1_CTL", "CA1_SZ", "CA3_CTL", "CA3_SZ", "DG_CTL", "DG_SZ"), times = c(13, 13, 12, 13, 13, 13)))
coldata <- names(count_nooutlier)


# Create the plot using ggplot
ggplot(mdsPoisData_rm_CA3_CTL_12, aes(x_coord, y_coord, color = groups, label = coldata)) + 
  geom_text(size = 2) +
  scale_colour_manual(values=c("green", "blue", "grey", "cyan", "red", "yellow"))+
  ggtitle('Multi Dimensional Scaling') +
  labs(x = "Poisson Distance", y = "Poisson Distance") +
  theme_bw()+
  labs(caption = "Figure: MDS plot with outlier removed")
```

TODOs voor kwaliteitscontrole:
- normaliseren met DESeq2 vst()
- annotation dataframe maken (zie 3.4.3)
- MDS (eerst in 1 plot)





The raw counts data was normalized again by calculating the fragments per million mapped fragments (FPM), this is equal to CPM (counts per million). The log2 was calculated of these given values. 

```{r}
counts.fpm <- log2( (counts / (colSums(counts) / 1e6)) + 1 )
```

```{r}
annotation$Group <- paste(annotation$Condition, annotation$Region, annotation$Drug, sep="_")
dds <- DESeqDataSetFromMatrix(countData = counts,
                              colData = annotation,
                              design = ~ 0 + Group)
dds <- DESeq(dds)
resultsNames(dds)
res <- results(dds, contrast = c("Group", "schizophrenia_CA3_ON", "control_CA3_OFF"), alpha = 0.05)
summary(res)
```


volcano plat maken


```{r}
library(EnhancedVolcano)
library(ggrepel)

## Simple function for plotting a Volcano plot, returns a ggplot object
deseq.volcano <- function(res, datasetName) {
  return(EnhancedVolcano(res, x = 'log2FoldChange', y = 'padj',
                         lab=rownames(res),
                         title = paste(datasetName, "trisomic vs disomic"),
                         subtitle = bquote(italic('FDR <= 0.05 and absolute FC >= 2')),
                         # Change text and icon sizes
                         labSize = 3, pointSize = 1.5, axisLabSize=10, titleLabSize=12,
                         subtitleLabSize=8, captionLabSize=10,
                         # Disable legend
                         legendPosition = "none",
                         # Set cutoffs
                         pCutoff = 0.05, FCcutoff = 2))
}

deseq.volcano(res = res, datasetName = "IPSC")
```

